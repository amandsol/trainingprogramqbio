# --------------------------------------------------#
# Scientific computing
# ICTP/Serrapilheira 2022
# First version 2022-07-27
# Class 11: Biodiversity databases
# --------------------------------------------------#
#install.packages("rgbif")
#install.packages("Taxonstand")
#install.packages("CoordinateCleaner")
#install.packages("maps")

library(rgbif)
library(Taxonstand)
library(CoordinateCleaner)
library(maps)
library(dplyr)

#download the data of a Primulaceae species from South America Myrsine coriacea
species <- "Myrsine coriacea"

#search for GBIF occurrences
?occ_search
occs <- occ_search(scientificName = species,
                   limit = 100000)
names(occs)

#The occurrences are saved in occs$data. Let’s create a new object from this table
myrsine.data <- occs$data

#Column names returned from gbif follow the DarwinCore standard
colnames(myrsine.data)

#We will create a directory to save data and then export the data as csv
dir.create("data/raw/", recursive = TRUE)
write.csv(myrsine.data,
          "data/raw/10_myrsine_data.csv",
          row.names = FALSE)

#check the unique entries for the species name we just searched
sort(unique(myrsine.data$scientificName))

#In the gbif data, there is already a column showing the currently accepted taxonomy:
table(myrsine.data$taxonomicStatus)

#check which of the names are accepted or not
table(myrsine.data$scientificName, myrsine.data$taxonomicStatus)

#use the function TPL() from package taxonstand to check if the taxonomic updates
#in the gbif data are correct
#This function receives a vector containing a list of species and performs both
#orthographical and nomenclature checking. Nomenclature checking follows The Plant List

#generate a list with unique species names and combine it to the data
#data frame with the original names
species.names <- unique(myrsine.data$scientificName)
dim(species.names)


tax.check <- TPL(species.names)

tax.check

# merge the new genus and species and then add them to the original data
# creating new object w/ original and new names after TPL
new.tax <- data.frame(scientificName = species.names,
                      genus.new.TPL = tax.check$New.Genus,
                      species.new.TPL = tax.check$New.Species,
                      status.TPL = tax.check$Taxonomic.status,
                      scientificName.new.TPL = paste(tax.check$New.Genus,
                                                     tax.check$New.Species))
# now we are merging raw data and checked data
myrsine.new.tax <- merge(myrsine.data, new.tax, by = "scientificName")

#Exporting data after taxonomy check
#export the data after the taxonomy check
dir.create("data/processed/", recursive = TRUE)
write.csv(myrsine.new.tax,
          "data/processed/10_data_taxonomy_check.csv",
          row.names = FALSE)

#Checking species’ coordinates
#inspect visually the coordinates in the raw data
plot(decimalLatitude ~ decimalLongitude, data = myrsine.data, asp = 1)
map(, , , add = TRUE)


#the function clean_coordinates() from the CoordinateCleaner package to clean
#the species records.  This function checks for common errors in coordinates
#such as institutional coordinates, sea coordinates, outliers, zeros, centroids, etc.
#This function does not accept not available information (here addressed as “NA”)
#so we will first select only data that have a numerical value for both latitude and longitude
myrsine.coord <- myrsine.data[!is.na(myrsine.data$decimalLatitude)
                              & !is.na(myrsine.data$decimalLongitude),]

#Now that we don’t have NA in latitude or longitude, we can perform the coordinate cleaning
# output w/ only potential correct coordinates
geo.clean <- clean_coordinates(x = myrsine.coord,
                               lon = "decimalLongitude",
                               lat = "decimalLatitude",
                               species = "species",
                               value = "clean")

#Let’s plot the output of the clean data
par(mfrow = c(1, 2))
plot(decimalLatitude ~ decimalLongitude, data = myrsine.data, asp = 1)
map(, , , add = TRUE)
plot(decimalLatitude ~ decimalLongitude, data = geo.clean, asp = 1)
map(, , , add = TRUE)
par(mfrow = c(1, 1))

#Setting value = clean it returns only the potentially correct coordinate
#For checking and reproducibility we want to save all the output with the flag
#generated by the routine. Let’s try a different output
myrsine.new.geo <- clean_coordinates(x = myrsine.coord,
                                     lon = "decimalLongitude",
                                     lat = "decimalLatitude",
                                     species = "species",
                                     value = "spatialvalid")

table(myrsine.new.geo$.summary)

tail(names(myrsine.new.geo))

#merge the raw data with the cleaned data
# merging w/ original data
myrsine.new.geo2 <- merge(myrsine.data, myrsine.new.geo,
                          all.x = TRUE)
dim(myrsine.new.geo2)

plot(decimalLatitude ~ decimalLongitude, data = myrsine.new.geo, asp = 1)
map(, , , add = TRUE)

#Exporting the data after coordinate check
plot(decimalLatitude ~ decimalLongitude, data = myrsine.new.geo2, asp = 1,
     col = if_else(myrsine.new.geo2$.summary, "green", "red"))
map(, , , add = TRUE)

#save the dataset as a shapefile
library(tmap)
library(sf)
myrsine.final <- left_join(myrsine.coord, myrsine.new.geo2)
nrow(myrsine.final)

myrsine_sf <- st_as_sf(myrsine.final, coords = c("decimalLongitude", "decimalLatitude"))
st_crs(myrsine_sf)

myrsine_sf <- st_set_crs(myrsine_sf, 4326)
st_crs(myrsine_sf)

## Plot with tmap
data(World)

SAm_map <- World %>%
  filter(continent %in% c("South America", "North America")) %>%
  tm_shape() +
  tm_borders()


SAm_map +
  tm_shape(myrsine_sf) +
  tm_bubbles(size = 0.2,
             col = ".summary")

#Interactive mode in tmap
#The option tmap_mode("view") creates interactive maps. For this, we need to
#transform the data frame into a sf shapefile
tmap_mode("view")
World %>%
  filter(continent %in% c("South America", "North America")) %>%
  tm_shape() +
  tm_borders() +
  tm_shape(myrsine_sf) +
  tm_bubbles(size = 0.2)
